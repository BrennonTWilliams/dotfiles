#!/usr/bin/env zsh
# ==============================================================================
# Cross-Platform Shell Utilities
# ==============================================================================
# Provides consistent utilities across macOS and Linux/Sway environments
# Detects platform, handles platform-specific commands, and abstracts differences

# ==============================================================================
# Platform Detection
# ==============================================================================

# Detect operating system
detect_os() {
    case "$(uname -s)" in
        Darwin*)    echo "macos" ;;
        Linux*)     echo "linux" ;;
        CYGWIN*|MINGW*|MSYS*) echo "windows" ;;
        *)          echo "unknown" ;;
    esac
}

# Detect Linux distribution
detect_linux_distro() {
    if [[ -f /etc/os-release ]]; then
        . /etc/os-release
        echo "$ID"
    elif command -v lsb_release >/dev/null 2>&1; then
        lsb_release -si | tr '[:upper:]' '[:lower:]'
    else
        echo "unknown"
    fi
}

# Detect desktop environment/window manager
detect_desktop_env() {
    if [[ -n "$SWAYSOCK" ]]; then
        echo "sway"
    elif [[ -n "$WAYLAND_DISPLAY" ]]; then
        echo "wayland"
    elif [[ -n "$DISPLAY" ]]; then
        if command -v i3 >/dev/null 2>&1; then
            echo "i3"
        else
            echo "x11"
        fi
    else
        echo "unknown"
    fi
}

# Detect terminal emulator
detect_terminal() {
    if [[ -n "$GHOSTTY_RESOURCES" ]]; then
        echo "ghostty"
    elif [[ -n "$FOOT_TERMINAL_ID" ]]; then
        echo "foot"
    elif [[ -n "$KITTY_WINDOW_ID" ]]; then
        echo "kitty"
    elif [[ "$TERM" == "alacritty" ]]; then
        echo "alacritty"
    elif [[ "$TERM_PROGRAM" == "vscode" ]]; then
        echo "vscode"
    elif [[ "$TERM_PROGRAM" == "wezterm" ]]; then
        echo "wezterm"
    else
        echo "$TERM"
    fi
}

# ==============================================================================
# Dynamic Path Resolution System with Caching
# ==============================================================================

# Cache for resolved paths - using associative array for O(1) lookups
typeset -gA _PLATFORM_PATH_CACHE

# Cache for platform detection results to avoid repeated subprocess calls
typeset -g _CACHED_OS=""
typeset -g _CACHED_USERNAME=""
typeset -g _CACHED_USER_HOME=""

# Get user's home directory in a cross-platform way
get_user_home() {
    # Use the standard HOME environment variable for portability
    echo "$HOME"
}

# Get user's username in a cross-platform way (with caching)
get_username() {
    if [[ -n "$_CACHED_USERNAME" ]]; then
        echo "$_CACHED_USERNAME"
        return
    fi

    if command -v whoami >/dev/null 2>&1; then
        _CACHED_USERNAME=$(whoami)
    elif [[ -n "$USER" ]]; then
        _CACHED_USERNAME="$USER"
    elif [[ -n "$USERNAME" ]]; then
        _CACHED_USERNAME="$USERNAME"
    else
        _CACHED_USERNAME="user"  # Safe fallback
    fi
    echo "$_CACHED_USERNAME"
}

# Cached OS detection
_get_cached_os() {
    if [[ -n "$_CACHED_OS" ]]; then
        echo "$_CACHED_OS"
        return
    fi

    _CACHED_OS=$(detect_os)
    echo "$_CACHED_OS"
}

# Cached home directory
_get_cached_home() {
    if [[ -n "$_CACHED_USER_HOME" ]]; then
        echo "$_CACHED_USER_HOME"
        return
    fi

    _CACHED_USER_HOME=$(get_user_home)
    echo "$_CACHED_USER_HOME"
}

# Resolve platform-specific paths dynamically with caching
resolve_platform_path() {
    local path_type="$1"

    # Check cache first - this eliminates all subprocess calls for cached paths
    if [[ -n "${_PLATFORM_PATH_CACHE[$path_type]}" ]]; then
        echo "${_PLATFORM_PATH_CACHE[$path_type]}"
        return
    fi

    # Resolve the path (only happens once per path_type)
    local username="$(get_username)"
    local user_home="$(_get_cached_home)"
    local os="$(_get_cached_os)"
    local resolved_path=""

    case "$path_type" in
        "dotfiles")
            # Standard dotfiles location (users can override in .zshrc.local)
            resolved_path="$user_home/.dotfiles"
            ;;
        "conda_root")
            case "$os" in
                "macos") resolved_path="$user_home/miniforge3" ;;
                "linux") resolved_path="$user_home/miniforge3" ;;
                *) resolved_path="$user_home/miniforge3" ;;
            esac
            ;;
        "conda_bin")
            local conda_root="$(resolve_platform_path "conda_root")"
            resolved_path="$conda_root/bin"
            ;;
        "conda_profile")
            local conda_root="$(resolve_platform_path "conda_root")"
            resolved_path="$conda_root/etc/profile.d/conda.sh"
            ;;
        "docker_completions")
            case "$os" in
                "macos") resolved_path="/Users/$username/.docker/completions" ;;
                "linux") resolved_path="$user_home/.docker/completions" ;;
                *) resolved_path="$user_home/.docker/completions" ;;
            esac
            ;;
        "npm_global")
            resolved_path="$user_home/.npm-global"
            ;;
        "npm_global_bin")
            resolved_path="$(resolve_platform_path "npm_global")/bin"
            ;;
        "local_lib")
            case "$os" in
                "macos") resolved_path="$user_home/.local/lib" ;;
                "linux") resolved_path="$user_home/.local/lib" ;;
                *) resolved_path="$user_home/.local/lib" ;;
            esac
            ;;
        "starship_config")
            resolved_path="$user_home/.config/starship"
            ;;
        "vscode_config")
            case "$os" in
                "macos") resolved_path="$user_home/Library/Application Support/Code/User" ;;
                "linux") resolved_path="$user_home/.config/Code/User" ;;
                *) resolved_path="$user_home/.config/Code/User" ;;
            esac
            ;;
        "gitconfig")
            resolved_path="$user_home/.gitconfig"
            ;;
        "npmrc")
            resolved_path="$user_home/.npmrc"
            ;;
        "ssh_dir")
            resolved_path="$user_home/.ssh"
            ;;
        "tmux_local")
            resolved_path="$user_home/.tmux.local"
            ;;
        "zshrc_local")
            resolved_path="$user_home/.zshrc.local"
            ;;
        "zshenv_local")
            resolved_path="$user_home/.zshenv.local"
            ;;
        "zprofile_local")
            resolved_path="$user_home/.zprofile.local"
            ;;
        "bashrc_local")
            resolved_path="$user_home/.bashrc.local"
            ;;
        "bash_profile_local")
            resolved_path="$user_home/.bash_profile.local"
            ;;
        "gitconfig_local")
            resolved_path="$user_home/.gitconfig.local"
            ;;
        "npmrc_local")
            resolved_path="$user_home/.npmrc.local"
            ;;
        *)
            echo "âŒ Unknown path type: $path_type" >&2
            return 1
            ;;
    esac

    # Cache the resolved path for future lookups
    _PLATFORM_PATH_CACHE[$path_type]="$resolved_path"
    echo "$resolved_path"
}

# Pre-populate cache with commonly used paths for optimal performance
# This eliminates subprocess calls during shell initialization
_init_path_cache() {
    # Pre-resolve the most frequently accessed paths
    # These are typically called multiple times in .zshrc
    local common_paths=(
        "docker_completions"
        "conda_bin"
        "conda_profile"
        "conda_root"
        "npm_global_bin"
        "starship_config"
        "dotfiles"
        "local_lib"
    )

    # Resolve each path once to populate cache
    for path_type in "${common_paths[@]}"; do
        resolve_platform_path "$path_type" >/dev/null 2>&1
    done
}

# Export path resolution functions for use in other scripts
# Note: Functions are automatically available in the current shell context

# Initialize the path cache immediately for maximum performance
_init_path_cache

# Set commonly used environment variables (these will now use cached values)
export DOTFILES_DIR="$(resolve_platform_path "dotfiles")"
export CONDA_ROOT="$(resolve_platform_path "conda_root")"
export CONDA_BIN="$(resolve_platform_path "conda_bin")"

# ==============================================================================
# Cross-Platform Command Abstractions
# ==============================================================================

# Cross-platform clipboard operations
clipboard_copy() {
    local content="$1"
    case "$(detect_os)" in
        macos)
            echo "$content" | pbcopy
            ;;
        linux)
            if command -v wl-copy >/dev/null 2>&1 && [[ -n "$WAYLAND_DISPLAY" ]]; then
                echo "$content" | wl-copy
            elif command -v xclip >/dev/null 2>&1; then
                echo "$content" | xclip -selection clipboard
            elif command -v xsel >/dev/null 2>&1; then
                echo "$content" | xsel --clipboard --input
            else
                echo "âŒ No clipboard command found on Linux"
                return 1
            fi
            ;;
        *)
            echo "âŒ Unsupported OS for clipboard operations"
            return 1
            ;;
    esac
}

clipboard_paste() {
    case "$(detect_os)" in
        macos)
            pbpaste
            ;;
        linux)
            if command -v wl-paste >/dev/null 2>&1 && [[ -n "$WAYLAND_DISPLAY" ]]; then
                wl-paste
            elif command -v xclip >/dev/null 2>&1; then
                xclip -selection clipboard -o
            elif command -v xsel >/dev/null 2>&1; then
                xsel --clipboard --output
            else
                echo "âŒ No clipboard command found on Linux"
                return 1
            fi
            ;;
        *)
            echo "âŒ Unsupported OS for clipboard operations"
            return 1
            ;;
    esac
}

# Cross-platform file open command
open_file() {
    local file="$1"
    case "$(detect_os)" in
        macos)
            open "$file"
            ;;
        linux)
            if command -v xdg-open >/dev/null 2>&1; then
                xdg-open "$file"
            else
                echo "âŒ xdg-open not found on Linux"
                return 1
            fi
            ;;
        *)
            echo "âŒ Unsupported OS for file opening"
            return 1
            ;;
    esac
}

# Cross-platform notification system
send_notification() {
    local title="$1"
    local message="$2"
    case "$(detect_os)" in
        macos)
            osascript -e "display notification \"$message\" with title \"$title\""
            ;;
        linux)
            if command -v notify-send >/dev/null 2>&1; then
                notify-send "$title" "$message"
            else
                echo "âŒ notify-send not found on Linux"
                return 1
            fi
            ;;
        *)
            echo "âŒ Unsupported OS for notifications"
            return 1
            ;;
    esac
}

# Cross-platform screenshot capture
take_screenshot() {
    local area="${1:-full}"  # Options: full, window, selection
    local output_dir="${2:-$HOME/Desktop}"

    case "$(detect_os)" in
        macos)
            case "$area" in
                full)
                    screencapture "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                    ;;
                window)
                    screencapture -w "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                    ;;
                selection)
                    screencapture -s "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                    ;;
            esac
            ;;
        linux)
            if command -v grim >/dev/null 2>&1; then
                # Wayland screenshot with grim
                case "$area" in
                    full)
                        grim "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                        ;;
                    window)
                        grim -g "$(slurp -f '%wx%h+%x+%y')" "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                        ;;
                    selection)
                        grim -g "$(slurp)" "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                        ;;
                esac
            elif command -v import >/dev/null 2>&1; then
                # X11 screenshot with ImageMagick
                case "$area" in
                    full)
                        import -window root "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                        ;;
                    window)
                        import "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                        ;;
                    selection)
                        import -crop "$(import - | identify -format '%wx%h+%X+%Y' /dev/fd/0)" \
                               "$output_dir/screenshot-$(date +%Y%m%d-%H%M%S).png"
                        ;;
                esac
            else
                echo "âŒ No screenshot command found on Linux (install grim or ImageMagick)"
                return 1
            fi
            ;;
        *)
            echo "âŒ Unsupported OS for screenshots"
            return 1
            ;;
    esac
}

# ==============================================================================
# System Information
# ==============================================================================

# Cross-platform memory usage
get_memory_usage() {
    case "$(detect_os)" in
        macos)
            # macOS memory usage
            vm_stat | perl -ne '/page size of (\d+)/ and $ps=$1; /Pages free:\s+(\d+)/ and $pf=$1; /Pages active:\s+(\d+)/ and $pa=$1; /Pages inactive:\s+(\d+)/ and $pi=$1; /Pages wired down:\s+(\d+)/ and $pw=$1; END { printf "%.1fGB", ($pf+$pa+$pi+$pw)*$ps/1024/1024/1024; }'
            ;;
        linux)
            # Linux memory usage
            free -h | awk '/^Mem:/ {print $3 "/" $2}'
            ;;
        *)
            echo "N/A"
            ;;
    esac
}

# Cross-platform CPU usage
get_cpu_usage() {
    case "$(detect_os)" in
        macos)
            # macOS CPU usage
            ps -A -o %cpu | awk '{s+=$1} END {printf "%.1f%%", s}'
            ;;
        linux)
            # Linux CPU usage
            top -bn1 | grep "Cpu(s)" | awk '{print $2}' | sed 's/%us,//'
            ;;
        *)
            echo "N/A"
            ;;
    esac
}

# Cross-platform battery status
get_battery_status() {
    case "$(detect_os)" in
        macos)
            # macOS battery status
            pmset -g batt | grep -o '[0-9]*%' | head -1
            ;;
        linux)
            # Linux battery status
            if [[ -d /sys/class/power_supply/BAT0 ]]; then
                cat /sys/class/power_supply/BAT0/capacity
            elif [[ -d /sys/class/power_supply/BAT1 ]]; then
                cat /sys/class/power_supply/BAT1/capacity
            else
                echo "N/A"
            fi
            ;;
        *)
            echo "N/A"
            ;;
    esac
}

# ==============================================================================
# Package Management
# ==============================================================================

# Cross-platform package installation
install_package() {
    local package="$1"
    case "$(detect_os)" in
        macos)
            if command -v brew >/dev/null 2>&1; then
                brew install "$package"
            else
                echo "âŒ Homebrew not found on macOS"
                return 1
            fi
            ;;
        linux)
            local distro=$(detect_linux_distro)
            case "$distro" in
                ubuntu|debian)
                    sudo apt-get install -y "$package"
                    ;;
                fedora)
                    sudo dnf install -y "$package"
                    ;;
                arch|manjaro)
                    sudo pacman -S --noconfirm "$package"
                    ;;
                *)
                    echo "âŒ Unsupported Linux distribution: $distro"
                    return 1
                    ;;
            esac
            ;;
        *)
            echo "âŒ Unsupported OS for package installation"
            return 1
            ;;
    esac
}

# Cross-platform package update
update_packages() {
    case "$(detect_os)" in
        macos)
            if command -v brew >/dev/null 2>&1; then
                brew update && brew upgrade
            else
                echo "âŒ Homebrew not found on macOS"
                return 1
            fi
            ;;
        linux)
            local distro=$(detect_linux_distro)
            case "$distro" in
                ubuntu|debian)
                    sudo apt-get update && sudo apt-get upgrade -y
                    ;;
                fedora)
                    sudo dnf update -y
                    ;;
                arch|manjaro)
                    sudo pacman -Syu --noconfirm
                    ;;
                *)
                    echo "âŒ Unsupported Linux distribution: $distro"
                    return 1
                    ;;
            esac
            ;;
        *)
            echo "âŒ Unsupported OS for package updates"
            return 1
            ;;
    esac
}

# ==============================================================================
# Enhanced Shell Functions
# ==============================================================================

# Enhanced memory info function that works cross-platform
cross_platform_memory_info() {
    local mem_usage=$(get_memory_usage)
    echo "%F{014}ðŸ’¾ ${mem_usage}%f"  # Cyan memory info
}

# Enhanced CPU info function that works cross-platform
cross_platform_cpu_info() {
    local cpu_usage=$(get_cpu_usage)
    echo "%F{011}âš¡ ${cpu_usage}%f"  # Yellow CPU info
}

# Cross-platform workspace info
cross_platform_workspace_info() {
    local os=$(detect_os)
    local desktop=$(detect_desktop_env)
    local terminal=$(detect_terminal)

    # Start with platform info
    local info="ðŸ–¥ï¸ $os"
    [[ "$desktop" != "unknown" ]] && info="$info | $desktop"
    [[ "$terminal" != "unknown" ]] && info="$info | $terminal"

    # Add project context
    if git rev-parse --git-dir > /dev/null 2>&1; then
        local repo_name=$(basename $(git rev-parse --show-toplevel))
        info="$info | ðŸ“ $repo_name"
    elif [[ -f "package.json" ]]; then
        local project_name=$(jq -r .name package.json 2>/dev/null || echo "Node")
        info="$info | ðŸ“¦ $project_name"
    elif [[ -f "Cargo.toml" ]]; then
        local project_name=$(grep '^name = ' Cargo.toml | cut -d'"' -f2 || echo "Rust")
        info="$info | ðŸ¦€ $project_name"
    elif [[ -f "pyproject.toml" ]]; then
        local project_name=$(grep '^name = ' pyproject.toml | cut -d'"' -f2 || echo "Python")
        info="$info | ðŸ $project_name"
    fi

    echo "%F{013}$info%f"  # Magenta workspace info
}

# Cross-platform system status
system_status() {
    echo "ðŸ–¥ï¸  System Status"
    echo "================"
    echo "OS: $(detect_os)"
    echo "Desktop: $(detect_desktop_env)"
    echo "Terminal: $(detect_terminal)"
    echo "Memory: $(get_memory_usage)"
    echo "CPU: $(get_cpu_usage)"
    echo "Battery: $(get_battery_status)"
    echo ""
}

# Cross-platform platform-specific aliases
setup_platform_aliases() {
    case "$(detect_os)" in
        macos)
            alias ls='ls -G'
            alias ll='ls -laG'
            alias la='ls -laG'
            # macOS-specific commands
            alias show-files='defaults write com.apple.finder AppleShowAllFiles YES; killall Finder'
            alias hide-files='defaults write com.apple.finder AppleShowAllFiles NO; killall Finder'
            alias lock='/System/Library/CoreServices/Menu\\ Extras/User.menu/Contents/Resources/CGSession -suspend'
            ;;
        linux)
            alias ls='ls --color=auto'
            alias ll='ls -la --color=auto'
            alias la='ls -la --color=auto'
            # Linux-specific commands
            alias open='xdg-open'
            alias pbcopy='wl-copy || xclip -selection clipboard'
            alias pbpaste='wl-paste || xclip -selection clipboard -o'
            alias screenshot='take_screenshot'
            ;;
    esac
}

# ==============================================================================
# Uniclip Service Management
# ==============================================================================

# Cross-platform Uniclip service control
uniclip_manager() {
    local script_dir="$(dirname "$(readlink -f "${(%):-%x}")")"
    local uniclip_manager="$script_dir/../scripts/uniclip-manager"

    if [[ -f "$uniclip_manager" ]]; then
        "$uniclip_manager" "$@"
    else
        echo "âŒ Uniclip manager not found at: $uniclip_manager"
        return 1
    fi
}

# Convenience aliases for Uniclip management
alias uniclip-install='uniclip_manager install'
alias uniclip-uninstall='uniclip_manager uninstall'
alias uniclip-start='uniclip_manager start'
alias uniclip-stop='uniclip_manager stop'
alias uniclip-restart='uniclip_manager restart'
alias uniclip-status='uniclip_manager status'
alias uniclip-logs='uniclip_manager logs'
alias uniclip-enable='uniclip_manager enable'
alias uniclip-disable='uniclip_manager disable'

# ==============================================================================
# Development Environment Management
# ==============================================================================

# Cross-platform development environment setup
setup_dev_env() {
    local script_dir="$(dirname "$(readlink -f "${(%):-%x}")")"
    local setup_script="$script_dir/../scripts/setup-dev-env"

    if [[ -f "$setup_script" ]]; then
        "$setup_script" "$@"
    else
        echo "âŒ Development environment setup script not found at: $setup_script"
        return 1
    fi
}

# Convenience aliases for development environment management
alias dev-setup='setup_dev_env'
alias dev-install='setup_dev_env --update all'
alias dev-minimal='setup_dev_env --minimal core shell dev-tools'
alias dev-update='setup_dev_env --update'
alias dev-dryrun='setup_dev_env --dry-run all'

# ==============================================================================
# Health Check Integration
# ==============================================================================

# Cross-platform health check execution
dotfiles_health_check() {
    local script_dir="$(dirname "$(readlink -f "${(%):-%x}")")"
    local health_check_script="$script_dir/../scripts/health-check.sh"

    if [[ -f "$health_check_script" ]]; then
        "$health_check_script"
    else
        echo "âŒ Health check script not found at: $health_check_script"
        echo "Attempting basic health checks..."

        # Fallback basic checks
        echo "ðŸ” Basic Dotfiles Health Check"
        echo "=============================="

        # Check shell configuration
        if [[ -f "$HOME/.zshrc" ]]; then
            echo "âœ… .zshrc exists"
        else
            echo "âŒ .zshrc not found"
        fi

        # Check Starship
        if command -v starship >/dev/null 2>&1; then
            echo "âœ… Starship is installed"
        else
            echo "âŒ Starship not found"
        fi

        # Check core tools
        local core_tools=("git" "curl" "tmux")
        for tool in "${core_tools[@]}"; do
            if command -v "$tool" >/dev/null 2>&1; then
                echo "âœ… $tool is available"
            else
                echo "âŒ $tool not found"
            fi
        done
    fi
}

# Convenience aliases for health checks
alias health-check='dotfiles_health_check'
alias dotfiles-check='dotfiles_health_check'
alias system-health='dotfiles_health_check'

# Development environment status check
dev_status() {
    echo "ðŸ–¥ï¸  Development Environment Status"
    echo "==============================="
    echo

    # Platform information
    echo "Platform: $(detect_os) ${LINUX_DISTRO:+($LINUX_DISTRO)}"
    echo "Desktop: $(detect_desktop_env)"
    echo "Terminal: $(detect_terminal)"
    echo

    # Check core tools
    echo "ðŸ”§ Core Tools:"
    local core_tools=("git" "curl" "wget" "zsh" "tmux" "starship")
    for tool in "${core_tools[@]}"; do
        if command -v "$tool" >/dev/null 2>&1; then
            echo "  âœ… $tool"
        else
            echo "  âŒ $tool (not found)"
        fi
    done
    echo

    # Check development tools
    echo "ðŸ› ï¸  Development Tools:"
    local dev_tools=("python3" "neovim" "ripgrep" "fzf" "fd" "jq")
    for tool in "${dev_tools[@]}"; do
        if command -v "$tool" >/dev/null 2>&1; then
            echo "  âœ… $tool"
        else
            echo "  âŒ $tool (not found)"
        fi
    done
    echo

    # Check platform-specific tools
    echo "ðŸ–¥ï¸  Platform-Specific Tools:"
    case "$(detect_os)" in
        macos)
            local macos_tools=("ghostty" "rectangle" "sketchybar")
            for tool in "${macos_tools[@]}"; do
                if command -v "$tool" >/dev/null 2>&1; then
                    echo "  âœ… $tool"
                else
                    echo "  âŒ $tool (not found)"
                fi
            done
            ;;
        linux)
            local linux_tools=("sway" "waybar" "foot" "grim")
            for tool in "${linux_tools[@]}"; do
                if command -v "$tool" >/dev/null 2>&1; then
                    echo "  âœ… $tool"
                else
                    echo "  âŒ $tool (not found)"
                fi
            done
            ;;
    esac
    echo

    # Check services
    echo "ðŸ”„ Services:"
    if uniclip_manager status >/dev/null 2>&1; then
        echo "  âœ… Uniclip service"
    else
        echo "  âŒ Uniclip service (not running or not installed)"
    fi
    echo

    # Check shell configuration
    echo "ðŸš Shell Configuration:"
    if [[ "$SHELL" == *"zsh"* ]]; then
        echo "  âœ… Zsh is default shell"
    else
        echo "  âš ï¸  Zsh is not default shell (current: $SHELL)"
    fi

    if [[ -f "$HOME/.zshrc" ]]; then
        echo "  âœ… .zshrc exists"
    else
        echo "  âŒ .zshrc not found"
    fi

    if [[ -f "$HOME/.config/starship.toml" ]]; then
        echo "  âœ… Starship configuration exists"
    else
        echo "  âŒ Starship configuration not found"
    fi
    echo

    # Quick fix suggestions
    echo "ðŸ”§ Quick Actions:"
    if ! command -v starship >/dev/null 2>&1; then
        echo "  - Install Starship: setup_dev_env core"
    fi
    if ! uniclip_manager status >/dev/null 2>&1; then
        echo "  - Setup Uniclip: uniclip-install"
    fi
    if [[ "$SHELL" != *"zsh"* ]]; then
        echo "  - Set Zsh as default: chsh -s \$(which zsh)"
    fi

    echo
    echo "For full setup, run: dev-install"
    echo "For minimal setup, run: dev-minimal"
}

# ==============================================================================
# Initialization
# ==============================================================================

# Set up platform aliases automatically
setup_platform_aliases

# Export environment variables for scripts
export PLATFORM_OS=$(detect_os)
export PLATFORM_DESKTOP=$(detect_desktop_env)
export PLATFORM_TERMINAL=$(detect_terminal)

# ==============================================================================
# Usage Information
# ==============================================================================
# This script provides the following cross-platform utilities:
#
# Platform Detection:
# - detect_os() - Detect operating system
# - detect_linux_distro() - Detect Linux distribution
# - detect_desktop_env() - Detect desktop environment/window manager
# - detect_terminal() - Detect terminal emulator
#
# Cross-Platform Commands:
# - clipboard_copy() <text> - Copy text to clipboard
# - clipboard_paste() - Paste from clipboard
# - open_file() <file> - Open file with default application
# - send_notification() <title> <message> - Send system notification
# - take_screenshot() [area] [output_dir] - Take screenshot (full/window/selection)
#
# System Information:
# - get_memory_usage() - Get current memory usage
# - get_cpu_usage() - Get current CPU usage
# - get_battery_status() - Get battery percentage
# - system_status() - Display comprehensive system status
#
# Package Management:
# - install_package() <package> - Install package using appropriate manager
# - update_packages() - Update all system packages
#
# Enhanced Shell Functions:
# - cross_platform_memory_info() - Memory info for prompts
# - cross_platform_cpu_info() - CPU info for prompts
# - cross_platform_workspace_info() - Enhanced workspace context for prompts
#
# Environment Variables:
# - $PLATFORM_OS - Current operating system
# - $PLATFORM_DESKTOP - Current desktop environment
# - $PLATFORM_TERMINAL - Current terminal emulator
#
# Platform-specific aliases are automatically set up based on detected OS.